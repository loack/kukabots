&ACCESS RVP
&REL 1
&PARAM TPVW_VERSION = 3.3.5
DEF Cell( )
SPS_N=-1

VW (#VW_AUE_INIT,TRUE)
PENTER:
INTERRUPT DECL 10 WHEN $CYCFLAG[30]==FALSE DO VW(#FB_STOP,TRUE)
INTERRUPT ON 10
INT10=TRUE

SPS_FERTIG = FALSE
INTERRUPT DECL 10 WHEN $CYCFLAG[30]==FALSE DO VW(#FB_STOP,TRUE)
INTERRUPT ON 10
INT10=TRUE
VW(#VW_INIT,TRUE)
;VW_USR_R (#USR_INIT)
TRIGGER  WHEN DISTANCE=1 DELAY=-0.1 DO P0_MERKER=TRUE

;VW(#MPARA,TRUE)
;Define accerlation, velocity, and base

WHILE TRUE
IF KVPMOVE_ENABLE THEN
KVP_MOTION_END = FALSE

    IF KVP_PTP_MOTION THEN
        ; PTP motion
        PTP P1
    ENDIF
    IF KVP_LIN_MOTION THEN
        ; Linear motion
        PTP BUFFER_E6POS[1]
    ENDIF
    IF KVP_TRAJECTORY_MODE THEN
     
        ; Set global look-ahead and approximation
        $ADVANCE = NB_ADVANCE_POINTS
        $APO.CDIS = KVP_APROX_CDIS

        ; Reset flags for a new trajectory
        COM_TRAJECTORY_FINISHED = FALSE
        EXIT_TRAJECTORY = FALSE ; Ensure this flag is reset by external app too

        ;----Initialise by starting at first point of trajectory----------
        ; Le robot attend qu'au moins les 10 premiers points soit disponibles dans le buffer.
        WAIT FOR (READ_INDEX + 10)< WRITE_INDEX
        ; Ensure the robot is at the first point before starting the continuous path
        ; This separates the initial PTP move from the continuous LIN segment.
        ; Make sure BUFFER_E6POS[1] contains the actual start point of the trajectory.
        PTP BUFFER_E6POS[1]

        
        ; --- BOUCLE PRINCIPALE FIFO BUFFER---
        LOOP
            ; Condition de sortie de la boucle (si Python a fini et tout a été lu)
            IF NOT KVP_TRAJECTORY_MODE AND (READ_INDEX >= WRITE_INDEX) THEN
                EXIT
            ENDIF

            ; --- SYNCHRONISATION ---
            ; Le robot attend ici SANS consommer de CPU
            ; qu'au moins un nouveau point soit disponible dans le buffer.
            WAIT FOR READ_INDEX < WRITE_INDEX
            
            ; --- LECTURE DU POINT ---
            ; On incrémente notre compteur de lecture
            READ_INDEX = READ_INDEX + 1
            
            ; On calcule l'index dans notre buffer circulaire (de 1 à 100)
            ; En KRL, la division d'entiers donne un résultat entier (tronqué)
            QUOTIENT = (READ_INDEX - 1) / 100  ; Calcul du quotient entier
            ; Calcul du reste (modulo)
            BUFFER_INDEX = (READ_INDEX - 1) - (100 * QUOTIENT) + 1
            
            COM_CURRENT_POINT_INDEX = BUFFER_INDEX

            ; On exécute le mouvement
            ; Utilisez PTP, LIN ou CIRC selon votre besoin
            LIN BUFFER_E6POS[BUFFER_INDEX] C_DIS

            ; If EXIT_TRAJECTORY was set, break out of the main LOOP as well
            IF EXIT_TRAJECTORY THEN
                EXIT
            ENDIF
            ; Flag to signal end of trajectory
            IF COM_ALL_POINTS THEN
                EXIT
            ENDIF
            
        ENDLOOP
        
        ; --- End of Trajectory Mode Enhancements ---
        COM_TRAJECTORY_FINISHED = TRUE
    ENDIF

ENDIF

KVP_MOTION_END = TRUE
WAIT SEC 0.1

ENDWHILE

END